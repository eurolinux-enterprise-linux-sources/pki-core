#!/usr/bin/perl
#
# --- BEGIN COPYRIGHT BLOCK ---
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Copyright (C) 2007-2010 Red Hat, Inc.
# All rights reserved.
# --- END COPYRIGHT BLOCK ---
#

use strict;
use warnings;

use Getopt::Long qw(GetOptions);

##############################################################
# This script is used to remove an existing PKI instance.
#
# To execute:
#
#   ./pkiremove -pki_instance_root=<pki_instance_root> # Instance root
#                                                      # directory destination
#
#               -pki_instance_name=<pki_instance_id>   # Unique PKI subsystem
#                                                      # instance name
#                                                      # (e. g. - pki-pki1)
#                       
#               [-force]                               # Don't ask any
#                                                      # questions
#
##############################################################


##############################################################
# Execution Check
##############################################################

# Check to insure that this script's original
# invocation directory has not been deleted!
my $cwd = `/bin/pwd`;
chomp $cwd;
if ($cwd eq "") {
    emit("Cannot invoke '$0' from non-existent directory!\n", "error");
    exit 255;
}

##############################################################
# Environment Variables
##############################################################

# untaint called subroutines
if (($^O ne 'Windows_NT') && ($^O ne 'MSWin32')) {
    $> = $<;   # set effective user ID to real UID
    $) = $(;   # set effective group ID to real GID
    $ENV{'PATH'} = '/bin:/usr/bin';
    $ENV{'ENV'} = '' if !defined($ENV{'ENV'});
}


##############################################################
# Command-Line Variables
##############################################################

my $ARGS = ($#ARGV + 1);


##############################################################
# Shared Common Perl Data and Subroutines
##############################################################

use lib "/usr/share/pki/scripts";
use pkicommon;

# make -w happy by suppressing warnings of Global variables used only once
my $suppress = "";
$suppress = $default_file_permissions;

##############################################################
# Local Constants
##############################################################

my $semanage = "/usr/sbin/semanage";

##############################################################
# Local Data Structures
##############################################################


##############################################################
# Local Variables
##############################################################

my $pki_instance_root               = undef;
my $pki_instance_name               = undef;
my $force                           = 0;

my $conf_file                       = undef;
my $pki_instance_path               = undef;
my $subsystem_type                  = undef;

# PKI init script variables
my $pki_registry_initscript         = undef;
my $pki_registry_initscript_command = undef;

# PKI registry variables
my $pki_registry_subsystem_path     = undef;

##############################################################
# Platform-Dependent Data Initialization
##############################################################

if ($^O eq "linux") {
} else {
    emit("Unsupported platform '$^O'!\n", "error");
    exit 255;
}

##############################################################
# Local Data Initialization
##############################################################

##############################################################
# PKI Instance Removal Subroutines
##############################################################

# no args
# no return value
sub usage
{
    print STDOUT <<'EOF';
Usage:  pkiremove -pki_instance_root=<pki_instance_root> # Instance root
                                                         # directory
                                                         # destination
                  -pki_instance_name=<pki_instance_id>   # Unique PKI
                                                         # subsystem
                                                         # instance name
                                                         # (e. g. - pki-pki1)

[-force]   # Don't ask any questions

[-verbose] # Display detailed information. May be specified multiple times,
           # each time increasing the verbosity level.

[-dry_run] # Do not perform any actions.
           # Just report what would have been done.

Example:  pkiremove -pki_instance_root=/var/lib -pki_instance_name=pki-ca

IMPORTANT:  Must be run as root!
EOF
    return;
}

sub update_domain
{
    my $sport;
    my $ncsport;
    my $sechost;
    my $httpport;
    my $seceeport;
    my $secagentport;
    my $secadminport;
    my $adminsport;
    my $agentsport;
    my $secselect;
    my $subsystemnick;
    my $machinename;
    my $subsytemnick;
    my $url;
    
    get_cs_cfg($conf_file, {"service.machineName"               => \$machinename,
                            "service.securityDomainPort"        => \$sport,
                            "service.non_clientauth_securePort" => \$ncsport,
                            "securitydomain.host"               => \$sechost,
                            "securitydomain.httpport"           => \$httpport,
                            "securitydomain.httpseeport"        => \$seceeport,
                            "securitydomain.httpsagentport"     => \$secagentport,
                            "securitydomain.httpsadminport"     => \$secadminport,
                            "securitydomain.select"             => \$secselect,
                            "pkiremove.cert.subsystem.nickname" => \$subsystemnick,
                            "pkicreate.admin_secure_port"       => \$adminsport,
                            "pkicreate.agent_secure_port"       => \$agentsport});


    # NOTE:  Don't check for the existence of $httpport, as this will
    #        be undefined for a Security Domain that has been migrated!
    if ((!defined($sechost))      ||
        (!defined($seceeport))    ||
        (!defined($secagentport)) ||
        (!defined($secadminport))) {
        print(STDOUT "No security domain defined.\nIf this is an unconfigured instance, then that is OK.\n" .
            "Otherwise, manually delete the entry from the security domain master.\n"); 
        return;
    }

    if ($secselect ne "new") {
        # This is not a domain master, so we need to update the master
        print(STDOUT "Contacting the security domain master to update the security domain\n");
        my $listval = $subsystem_type . "List";
        my $urlheader = "https://" . $sechost . ":" . $seceeport; 
        my $urlagentheader = "https://" . $sechost . ":" . $secagentport; 
        my $urladminheader = "https://" . $sechost . ":" . $secadminport; 
        my $updateURL = "/ca/agent/ca/updateDomainXML";   
        my $loginURL = "/ca/admin/ca/securityDomainLogin";
        my $cookieURL = "/ca/admin/ca/getCookie";

        # Login to security domain
        use LWP;
        my $browser= LWP::UserAgent->new;

        #create pk12 files for client cert authentication
        my $intpw;
        my $pwfile = $pki_instance_path . "/conf/password.conf";
        open(DAT, $pwfile) or die "Could not open password.conf file to generate pk12 files.";
        my @pw_data=<DAT>;
        foreach my $line (@pw_data) {
            chomp($line);

            if (($subsystem_type eq $CA)   ||
                ($subsystem_type eq $KRA)  ||
                ($subsystem_type eq $OCSP) ||
                ($subsystem_type eq $TKS)) {
                (my $varname, my $valname) = split(/=/, $line);
                if ($varname eq "internal") { $intpw = $valname; }
            } else {  # TPS, RA
                (my $varname, my $valname) = split(/:/, $line);
                if ($varname eq "internal") { $intpw = $valname; }
            }
        }
        close($pwfile);

        my $tempfile = "/tmp/" . $$ . ".p12";
        my $dbpath = $pki_instance_path . "/alias";
        srand(time() ^($$ + ($$ <<15))) ;
        my $p12pw = rand();

        my $errs = `pk12util -d $dbpath -o $tempfile -n "$subsystemnick" -K $intpw -W $p12pw 2>&1`;
        if ($? != 0) {
            emit($errs, "error");
            die "Could not generate pk12 file for client authentication.";
        }

        #update domainXML

        $url = $urlagentheader . $updateURL;
        #$ENV{'HTTPS_DEBUG'} = 1; 
        $ENV{'HTTPS_PKCS12_FILE'}     = $tempfile;
        $ENV{'HTTPS_PKCS12_PASSWORD'} = $p12pw;

        my $response = $browser->post($url, 
            [
                'name'       => $pki_instance_name,
                'type'       => $subsystem_type,
                'list'       => $listval,
                'host'       => $machinename,
                'sport'      => $sport,
                'ncsport'    => $ncsport,
                'adminsport' => $adminsport,
                'agentsport' => $agentsport,
                'operation'  => 'remove'
            ],
);
 
        ($response->is_success) or die ("$url error: " . $response->status_line);
        unlink $tempfile;
   } 
}

sub remove_fcontext
{
    my ($fcontext, $fname, $ftype) = @_;
    my $errs;

    emit(sprintf("remove_fcontext(%s)\n", join(", ", @_)), "debug");

    return if $dry_run;

    if ($ftype eq "f") {
        $errs = `$semanage fcontext -d -t $fcontext -f -- $fname 2>&1`
    } else {
        $errs = `$semanage fcontext -d -t $fcontext $fname 2>&1`
    }
    if (($? != 0)  && ($errs !~ /defined in policy, cannot be deleted/)) {
        emit("Failed setting selinux file context $fcontext for $fname ($errs)", "error");
    }
}

sub remove_selinux_fcontexts
{
    my $setype                = "pki_" . $subsystem_type;
    my $default_instance_name = "pki-" . $subsystem_type;
    my $default_instance_root = "/var/lib";
    my $default_log_path      = "/var/log/" . $default_instance_name;
    my $default_conf_path     = "/etc/" . $default_instance_name;

    my $log_path              = "$pki_instance_path/logs";
    my $conf_path             = "$pki_instance_path/conf";
    my $ftype;
    my $java_component        = 0;

    if (($subsystem_type eq $CA)   ||
        ($subsystem_type eq $KRA)  ||
        ($subsystem_type eq $OCSP) ||
        ($subsystem_type eq $TKS)) {
        $java_component=1;
    }

    if (-l $log_path) {
        $log_path = readlink $log_path;
    };
 
    if (-l $conf_path) {
        $conf_path = readlink $conf_path;
    };

    print STDOUT "Removing selinux file contexts.\n";

    # For backwards compatibility, support removal of instances
    # which use the legacy start/stop implementation
    if (entity_exists("$default_initscripts_path/$pki_instance_name")) {
        # remove context for "$default_initscripts_path/$pki_instance_name"
        if ($pki_instance_name ne $default_instance_name) {
            remove_fcontext($setype . "_script_exec_t", 
                              "/etc/rc\\.d/init\\.d/$pki_instance_name", "f");
        }
    }

    # remove context for $pki_instance_root/$pki_instance_name
    if (($pki_instance_name ne $default_instance_name) || ($pki_instance_root ne $default_instance_root)) {
        remove_fcontext($setype . "_var_lib_t", 
            "\"$pki_instance_root/$pki_instance_name(/.*)?\"", "a");
    }

    # remove context for /var/run/$pki_instance_name.pid
    if (($java_component) && ($pki_instance_name ne $default_instance_name)) {
        remove_fcontext($setype . "_var_run_t", 
            "/var/run/$pki_instance_name\\.pid", "f");
    }

    # remove context for $log_path
    if ($log_path ne $default_log_path) {
        remove_fcontext($setype . "_log_t",
            "\"$log_path(/.*)?\"", "a"); 
    }

    # remove context for $conf_path
    if ($conf_path ne $default_conf_path) {
         remove_fcontext($setype . "_etc_rw_t",
             "\"$conf_path(/.*)?\"", "a");
    }

}


sub remove_selinux_ports
{
    my $status;
    my $semanage = "/usr/sbin/semanage";
    my $secure_port;
    my $non_clientauth_secure_port;
    my $unsecure_port;
    my @ports = ();

    get_cs_cfg($conf_file, {"service.securePort"                => \$secure_port,
                            "service.non_clientauth_securePort" => \$non_clientauth_secure_port,
                            "service.unsecurePort"              => \$unsecure_port});

    if (($subsystem_type eq $CA)   ||
        ($subsystem_type eq $KRA)  ||
        ($subsystem_type eq $OCSP) ||
        ($subsystem_type eq $TKS)) {
        use XML::LibXML;
        my $parser = XML::LibXML->new();
        my $config = $parser->parse_file($pki_instance_path . "/conf/server.xml") 
            or die "Could not read XML from server.xml to determine ports.";
        
        my $root = $config->getDocumentElement;

        my $i = 0;
        foreach my $port ($root->findnodes('//@port')) {
            $ports[$i] = $port->getValue();
            $i++;
        }
    } else {  # TPS, RA
        my $i =0;
        if (defined $secure_port) {
            $ports[$i] = $secure_port;
            $i++;
        }
        if (defined $non_clientauth_secure_port) {
            $ports[$i] = $non_clientauth_secure_port;
            $i++;
        }
        if (defined $unsecure_port) {
            $ports[$i] = $unsecure_port;
            $i++;
        }
    }  

    print(STDOUT "\n");
    foreach my $port (@ports) {
        my $setype = "pki_" . $subsystem_type . "_port_t";
        my $errs;
        print STDOUT "Removing port $port from selinux policy.\n";
	next if $dry_run;
        $errs = `$semanage port -d -t $setype -ptcp $port 2>&1`;
        if ($? != 0)  {
            if ($errs !~ /defined in policy, cannot be deleted/) {
                warn "Port $port not removed from selinux policy correctly.\n";
                print $errs;
            } else {
                print "Port $port not removed from selinux policy because it is defined in policy.\nThis is OK.\n";
            }
        }
    }
}


# Return 1 if success, 0 if failure
sub remove_instance
{
    my ($result, $confirm, $install_info);
    $confirm = "Y";
    $result = 1;

    print(STDOUT "PKI instance Deletion Utility cleaning up instance ...\n\n");

ASK_AGAIN:
    if (!$force) {
        $confirm  = prompt("You have elected to remove the instance "
                          . "installed in $pki_instance_path.\n"
                          . "Are you sure (Y/N)? ");
    }

    if ($confirm eq "N" || $confirm eq "n") {
       return 1;
    } elsif ($confirm ne "Y" && $confirm ne "y") {
       goto ASK_AGAIN;
    }

    $install_info = read_install_info_from_dir($pki_instance_path);
    if (!defined($install_info)) {
        emit("Can't remove instance, installation manifest does not exist!", "error");
        return $result;
    }

    eval { update_domain(); } if !$dry_run; # FIXME so update_domain shows what it would do
    warn "Error updating security domain: " . $@ if $@;

    if (($^O eq "linux") && (is_Fedora() || (is_RHEL() && (! is_RHEL4())))) {
        eval { remove_selinux_ports(); };
        warn "Error removing selinux ports: " . $@ if $@; 

        eval { remove_selinux_fcontexts(); };
        warn "Error removing selinux file contexts: " . $@ if $@;
    }

    # De-register this instance with "chkconfig"
    if ($^O eq "linux") {
        if (entity_exists("$default_initscripts_path/$pki_instance_name")) {
            # De-register this instance with '/sbin/chkconfig'
            print(STDOUT "Removing '$pki_instance_name' from chkconfig.\n");
            deregister_pki_instance_with_chkconfig($pki_instance_name);
        }
    }

    $pki_registry_initscript = get_registry_initscript_name($subsystem_type);

    # Shutdown this instance
    if ($^O eq "linux") {
        if (entity_exists("$default_initscripts_path/$pki_instance_name")) {
            $pki_registry_initscript_command = "/sbin/service $pki_instance_name stop";
        } else {
            $pki_registry_initscript_command = "/sbin/service $pki_registry_initscript stop $pki_instance_name";
        }
    } else {
        emit("Unsupported platform '$^O'!\n", "error");
        exit 255;
    }
    run_command($pki_registry_initscript_command);

    print(STDOUT "\n");

    # Remove all installed files and directories.
    $result = 0 if !uninstall($install_info);

    print(STDOUT "\n");

    return $result;
}


##############################################################
# Main Program
##############################################################

# no args
# return 1 - success, or
# return 0 - failure
sub main
{
    chdir("/tmp");

    my $result = 0;

    print(STDOUT "PKI instance Deletion Utility ...\n\n");

    # On Linux/UNIX, insure that this script is being run as "root".
    $result = check_for_root_UID();
    if (!$result) {
        usage();
        exit 255;
    }

    # Check for a valid number of command-line arguments.
    if ($ARGS < 2) {
        emit("$0:  Insufficient arguments!", "error");
        usage();
        exit 255;
    }

    # Parse command-line arguments.
    $result = GetOptions("pki_instance_root=s" => \$pki_instance_root,
                         "pki_instance_name=s" => \$pki_instance_name,
                         "verbose+"            => \$verbose,
                         "dry_run"             => \$dry_run,
                         "force"               => \$force);

    # Always disallow root to be the pki_instance_root.
    if ($pki_instance_root eq "/") {
        emit("$0:  Don't even think about making root "
             . "the pki_instance_root!", "error");
        usage();
        exit 255;
    }

    $pki_instance_root = normalize_path($pki_instance_root);

    # Check for valid content of command-line arguments.
    if ($pki_instance_root eq "") {
        emit("$0:  Must have value for -pki_instance_root!", "error");
        usage();
        exit 255;
    }

    if ($pki_instance_name eq "") {
        emit("$0:  The instance ID of the PKI instance "
             . "to be removed is required!", "error");
        usage();
        exit 255;
    }

    $pki_instance_path = "${pki_instance_root}/${pki_instance_name}";

    if (!directory_exists($pki_instance_path)) {
        emit("$0:  Target directory $pki_instance_path "
             . "is not a legal directory.", "error");
        usage();
        exit 255;
    }

    # Capture uninstall information in a log file, always overwrite this file.
    # When removing an instance it's never a fatal error if the logfile
    # cannot be created.
    my $logfile = "/var/log/${pki_instance_name}-uninstall.log"; 
    open_logfile($logfile, $default_file_permissions);

    emit("Capturing installation information in $logfile.\n");

    if ($verbose) {
        emit("    verbose mode ENABLED (level=$verbose)\n");
    }

    if ($dry_run) {
        emit("    dry run mode ENABLED, system will not be modified, log to $logfile\n");
        print STDOUT "dry run mode ENABLED, system will not be modified\n";
    }

    emit("    pki_instance_root   $pki_instance_root\n");
    emit("    pki_instance_name   $pki_instance_name\n");
    emit("    pki_instance_path   $pki_instance_path\n");

    $conf_file = $pki_instance_path . "/conf/CS.cfg";
    $subsystem_type = get_cs_cfg($conf_file, "cs.type");
    if (!defined($subsystem_type)) {
        emit("Could not determine the subsystem type from the file \"$conf_file\"\n", "error");
        exit 1;
    }
    $subsystem_type =  lc($subsystem_type);

    # Remove the specified instance
    $result = remove_instance();
    if ($result != 1) {
        exit 255;
    }

    # Establish PKI subsystem-level registry
    $pki_registry_subsystem_path = "$pki_registry_path/$subsystem_type";

    # If empty, remove the PKI subsystem-level registry
    if (directory_exists($pki_registry_subsystem_path)) {
        if (is_directory_empty($pki_registry_subsystem_path)) {
            remove_directory($pki_registry_subsystem_path);
        }
    }

    # If empty, remove the PKI-level registry
    if (directory_exists($pki_registry_path)) {
        if (is_directory_empty($pki_registry_path)) {
            remove_directory($pki_registry_path);
        }
    }

    if ($dry_run) {
        print STDOUT "dry run mode ENABLED, system was not modified\n";
    }

    return $result;
}


##############################################################
# PKI Instance Removal
##############################################################

main();

exit 0;

